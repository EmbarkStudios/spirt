use std::rc::Rc;

fn main() -> std::io::Result<()> {
    match &std::env::args().collect::<Vec<_>>()[..] {
        [_, in_file] => {
            let cx = Rc::new(spirt::Context::new());
            let module = spirt::Module::lower_from_spv_file(cx.clone(), in_file)?;

            let print_operands = |operands: &[_]| {
                spirt::spv::print::OperandPrinter {
                    operands: operands.iter(),
                    out: std::io::stderr().lock(),
                }
                .all_operands()
                .unwrap();
            };

            let spv_spec = spirt::spv::spec::Spec::get();
            let wk = &spv_spec.well_known;

            match &module.dialect {
                spirt::ModuleDialect::Spv(dialect) => {
                    eprintln!(
                        "SPIR-V {}.{} module:",
                        dialect.version_major, dialect.version_minor
                    );

                    if !dialect.capabilities.is_empty() {
                        eprintln!("  Capabilities:");
                        for &cap in &dialect.capabilities {
                            // HACK(eddyb) this is one shorter because
                            // `print_operands` always prints a space first.
                            eprint!("   ");
                            print_operands(&[spirt::spv::print::PrintOperand::Imm(
                                spirt::spv::Imm::Short(wk.Capability, cap),
                            )]);
                            eprintln!();
                        }
                    }

                    if !dialect.extensions.is_empty() {
                        eprintln!("  Extensions:");
                        for ext in &dialect.extensions {
                            eprintln!("    {:?}", ext);
                        }
                    }

                    // HACK(eddyb) this lacks a space because
                    // `print_operands` always prints a space first.
                    eprint!("  Addressing model:");
                    print_operands(&[spirt::spv::print::PrintOperand::Imm(
                        spirt::spv::Imm::Short(wk.AddressingModel, dialect.addressing_model),
                    )]);
                    eprintln!();

                    // HACK(eddyb) this lacks a space because
                    // `print_operands` always prints a space first.
                    eprint!("  Memory model:");
                    print_operands(&[spirt::spv::print::PrintOperand::Imm(
                        spirt::spv::Imm::Short(wk.MemoryModel, dialect.memory_model),
                    )]);
                    eprintln!();
                }
            }

            match &module.debug_info {
                spirt::ModuleDebugInfo::Spv(debug_info) => {
                    if let Some(generator_magic) = debug_info.original_generator_magic {
                        let (tool_id, tool_version) =
                            (generator_magic.get() >> 16, generator_magic.get() as u16);
                        eprintln!(
                            "  Generated by Tool ID {} version {}",
                            tool_id, tool_version
                        );
                    }

                    if !debug_info.source_languages.is_empty() {
                        eprintln!("  Source languages:");
                        for (lang, sources) in &debug_info.source_languages {
                            // HACK(eddyb) this is one shorter because
                            // `print_operands` always prints a space first.
                            eprint!("   ");
                            print_operands(&[spirt::spv::print::PrintOperand::Imm(
                                spirt::spv::Imm::Short(wk.SourceLanguage, lang.lang),
                            )]);
                            eprintln!(" {}", lang.version);

                            for (&file, contents) in &sources.file_contents {
                                eprintln!("      {:?}: {:?}", &cx[file], contents);
                            }
                        }
                    }

                    if !debug_info.source_extensions.is_empty() {
                        eprintln!("  Source extensions:");
                        for ext in &debug_info.source_extensions {
                            eprintln!("    {:?}", ext);
                        }
                    }

                    if !debug_info.module_processes.is_empty() {
                        eprintln!("  Module processes:");
                        for proc in &debug_info.module_processes {
                            eprintln!("    {:?}", proc);
                        }
                    }
                }
            }

            eprintln!("  All other instructions:");
            let globals_and_func_insts = module
                .globals
                .iter()
                .map(|global| match global {
                    spirt::Global::Misc(misc) => misc,
                })
                .chain(module.funcs.iter().flat_map(|func| &func.insts));
            for misc in globals_and_func_insts {
                eprint!("    ");

                if let Some(output) = &misc.output {
                    match *output {
                        spirt::MiscOutput::SpvResult {
                            result_type_id,
                            result_id,
                        } => {
                            eprint!("%{}", result_id);
                            if let Some(type_id) = result_type_id {
                                eprint!(": %{}", type_id);
                            }
                            eprint!(" = ");
                        }
                    }
                }

                let name = match misc.kind {
                    spirt::MiscKind::SpvInst { opcode } => {
                        spv_spec.instructions.get_named(opcode).unwrap().0
                    }
                };
                eprint!("{}", name);

                // FIXME(eddyb) try to make this a bit more ergonomic.
                print_operands(
                    &misc
                        .inputs
                        .iter()
                        .map(|input| match *input {
                            spirt::MiscInput::SpvImm(imm) => {
                                spirt::spv::print::PrintOperand::Imm(imm)
                            }
                            spirt::MiscInput::SpvUntrackedId(id) => {
                                spirt::spv::print::PrintOperand::IdLike(format!("%{}", id))
                            }
                            spirt::MiscInput::SpvExtInstImport(name) => {
                                spirt::spv::print::PrintOperand::IdLike(format!(
                                    "%(OpExtInstImport {:?})",
                                    &cx[name]
                                ))
                            }
                        })
                        .collect::<Vec<_>>(),
                );
                eprintln!();

                for attr in cx[misc.attrs].attrs.iter() {
                    eprint!("      ");
                    match attr {
                        spirt::Attr::SpvEntryPoint {
                            params,
                            interface_ids,
                        } => {
                            eprint!("OpEntryPoint");

                            // FIXME(eddyb) try to make this a bit more ergonomic.
                            print_operands(
                                &params
                                    .iter()
                                    .map(|&imm| spirt::spv::print::PrintOperand::Imm(imm))
                                    .chain(interface_ids.iter().map(|&id| {
                                        spirt::spv::print::PrintOperand::IdLike(format!("%{}", id))
                                    }))
                                    .collect::<Vec<_>>(),
                            );
                            eprintln!();
                        }
                        spirt::Attr::SpvAnnotation { opcode, params } => {
                            let name = spv_spec.instructions.get_named(*opcode).unwrap().0;
                            eprint!("{}", name);

                            // FIXME(eddyb) try to make this a bit more ergonomic.
                            print_operands(
                                &params
                                    .iter()
                                    .map(|&imm| spirt::spv::print::PrintOperand::Imm(imm))
                                    .collect::<Vec<_>>(),
                            );
                            eprintln!();
                        }
                        &spirt::Attr::SpvDebugLine {
                            file_path,
                            line,
                            col,
                        } => {
                            // HACK(eddyb) Rust-GPU's column numbers seem
                            // off-by-one wrt what e.g. VSCode expects
                            // for `:line:col` syntax, but it's hard to
                            // tell from the spec and `glslang` doesn't
                            // even emit column numbers at all!
                            let col = col + 1;

                            // HACK(eddyb) only use skip string quoting
                            // and escaping for well-behaved file paths.
                            let file_path = &cx[file_path];
                            if file_path.chars().all(|c| c.is_ascii_graphic() && c != ':') {
                                eprintln!("at {}:{}:{}", file_path, line, col);
                            } else {
                                eprintln!("at {:?}:{}:{}", file_path, line, col);
                            }
                        }
                    }
                }

                // HACK(eddyb) this makes attr attachment more obvious.
                eprintln!();
            }

            Ok(())
        }
        args => {
            eprintln!("Usage: {} IN", args[0]);
            std::process::exit(1);
        }
    }
}
